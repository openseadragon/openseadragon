<!DOCTYPE html>
<html>
<head>
    <title>OpenSeadragon WebGL Context Recovery Demo</title>
    <script type="text/javascript" src='../../build/openseadragon/openseadragon.js'></script>
    <script type="text/javascript" src='../lib/jquery-1.9.1.min.js'></script>
    <style type="text/css">
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #controls {
            padding: 15px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        #controls label {
            margin-right: 10px;
        }
        #controls input[type="number"] {
            width: 60px;
            padding: 5px;
            margin-right: 10px;
        }
        #controls button {
            padding: 5px 15px;
            margin-right: 10px;
            margin-left: 10px;
        }
        #controls input[type="checkbox"] {
            margin-right: 5px;
        }
        #status {
            padding: 10px;
            background-color: #e8f4f8;
            border: 1px solid #b3d9e6;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        #status.error {
            background-color: #ffe8e8;
            border-color: #ffb3b3;
        }
        #status.success {
            background-color: #e8f8e8;
            border-color: #b3e6b3;
        }
        #viewers-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .viewer-wrapper {
            border: 2px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            background-color: #fafafa;
            position: relative;
        }
        .viewer-wrapper h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        .viewer-wrapper .remove-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 3px 8px;
            font-size: 12px;
            background-color: #ff6b6b;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .viewer-wrapper .remove-btn:hover {
            background-color: #ff5252;
        }
        .viewer-container {
            width: 400px;
            height: 300px;
        }
        .info {
            margin-top: 10px;
            padding: 10px;
            background-color: #fff;
            border-radius: 4px;
            font-size: 12px;
            color: #666;
        }
        .viewer-message {
            position: absolute;
            top: 30px;
            left: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
            display: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .viewer-message.success {
            background-color: #4caf50;
            color: white;
            display: block;
        }
        .viewer-message.error {
            background-color: #f44336;
            color: white;
            display: block;
        }
    </style>
</head>
<body>
    <h1>WebGL Context Recovery Demo</h1>
    <div class="info">
        <p>This demo tests WebGL context recovery when too many contexts are created.</p>
        <p><strong>Instructions:</strong></p>
        <ul>
            <li>Start with one viewer (already created)</li>
            <li>Add more viewers using the controls below to trigger context exhaustion</li>
            <li>Toggle "Enable Context Recovery" to see the difference between error state and recovered state</li>
            <li>When recovery is <strong>disabled</strong>: Viewers will crash with an error when context limit is reached</li>
            <li>When recovery is <strong>enabled</strong>: Viewers will automatically re-initialize their context and continue working</li>
        </ul>
    </div>

    <div id="controls">
        <label for="num-viewers">Add Viewers:</label>
        <input type="number" id="num-viewers" value="1" min="1" max="20">
        <button onclick="addViewers()">Add Viewers</button>

        <label style="margin-left: 20px;">
            <input type="checkbox" id="enable-recovery" checked onchange="toggleRecovery()">
            Enable Context Recovery
        </label>

        <button onclick="removeAllViewers()" style="margin-left: 20px; background-color: #ff6b6b; color: white;">Remove All</button>
    </div>

    <div id="status">
        <strong>Status:</strong> <span id="status-text">Ready</span><br>
        <strong>Active Viewers:</strong> <span id="viewer-count">0</span><br>
        <strong>Recovery Enabled:</strong> <span id="recovery-status">Yes</span>
    </div>

    <div id="viewers-container"></div>

    <script>
        let viewers = [];
        let viewerCounter = 0;
        let recoveryEnabled = true;

        function updateStatus(message, type = '') {
            const statusDiv = document.getElementById('status');
            const statusText = document.getElementById('status-text');
            statusText.textContent = message;
            statusDiv.className = type ? `status ${type}` : 'status';
        }

        function updateViewerCount() {
            document.getElementById('viewer-count').textContent = viewers.length;
        }

        function updateRecoveryStatus() {
            document.getElementById('recovery-status').textContent = recoveryEnabled ? 'Yes' : 'No';
        }

        function toggleRecovery() {
            recoveryEnabled = document.getElementById('enable-recovery').checked;
            viewers.forEach(viewerData => {
                if (viewerData && viewerData.viewer && viewerData.viewer.drawer && viewerData.viewer.drawer.setContextRecoveryEnabled) {
                    viewerData.viewer.drawer.setContextRecoveryEnabled(recoveryEnabled);
                }
            });
            updateRecoveryStatus();
            updateStatus(recoveryEnabled ? 'Context recovery enabled' : 'Context recovery disabled', recoveryEnabled ? 'success' : '');
        }

        function createViewer(viewerNumber) {
            const wrapper = document.createElement('div');
            wrapper.className = 'viewer-wrapper';
            wrapper.id = `viewer-wrapper-${viewerNumber}`;

            const title = document.createElement('h3');
            title.textContent = `Viewer ${viewerNumber}`;
            wrapper.appendChild(title);

            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = '×';
            removeBtn.onclick = () => removeViewer(viewerNumber);
            wrapper.appendChild(removeBtn);

            // Add message display element
            const messageDiv = document.createElement('div');
            messageDiv.className = 'viewer-message';
            messageDiv.id = `viewer-message-${viewerNumber}`;
            wrapper.appendChild(messageDiv);

            const container = document.createElement('div');
            container.className = 'viewer-container';
            container.id = `openseadragon-${viewerNumber}`;
            wrapper.appendChild(container);

            // Append to DOM first to ensure element exists
            const viewersContainer = document.getElementById('viewers-container');
            if (!viewersContainer) {
                updateStatus('Error: viewers-container not found', 'error');
                return null;
            }
            viewersContainer.appendChild(wrapper);

            // Use requestAnimationFrame to ensure DOM is ready before creating viewer
            requestAnimationFrame(() => {
                // Verify the container element exists in the DOM
                const containerElement = document.getElementById(`openseadragon-${viewerNumber}`);
                if (!containerElement) {
                    updateStatus(`Error: Container element not found for Viewer ${viewerNumber}`, 'error');
                    wrapper.remove();
                    return;
                }

                try {
                    const viewer = OpenSeadragon({
                        id: `openseadragon-${viewerNumber}`,
                        prefixUrl: "../../build/openseadragon/images/",
                        drawer: 'webgl',
                        tileSources: "../data/testpattern.dzi",
                        showNavigator: false,
                    });

                    // Set recovery enabled state
                    if (viewer.drawer && viewer.drawer.setContextRecoveryEnabled) {
                        viewer.drawer.setContextRecoveryEnabled(recoveryEnabled);
                    }

                    // Track errors
                    viewer.addHandler('tile-load-failed', function(event) {
                        updateStatus(`Viewer ${viewerNumber}: Tile load failed`, 'error');
                    });

                    // Listen for WebGL context recovery events
                    viewer.addHandler('webgl-context-recovered', function(event) {
                        const messageEl = document.getElementById(`viewer-message-${viewerNumber}`);
                        if (messageEl) {
                            messageEl.textContent = '✓ WebGL context recovered successfully!';
                            messageEl.className = 'viewer-message success';
                            // Auto-hide after 5 seconds
                            setTimeout(() => {
                                messageEl.className = 'viewer-message';
                            }, 5000);
                        }
                        updateStatus(`Viewer ${viewerNumber}: WebGL context recovered successfully`, 'success');
                    });

                    viewer.addHandler('webgl-context-recovery-failed', function(event) {
                        const messageEl = document.getElementById(`viewer-message-${viewerNumber}`);
                        if (messageEl) {
                            messageEl.textContent = '✗ WebGL context recovery failed - using canvas drawer';
                            messageEl.className = 'viewer-message error';
                            // Keep error message visible (don't auto-hide)
                        }
                        updateStatus(`Viewer ${viewerNumber}: WebGL context recovery failed`, 'error');
                    });

                    viewers.push({ number: viewerNumber, viewer: viewer, wrapper: wrapper });
                    updateViewerCount();
                    updateStatus(`Viewer ${viewerNumber} created successfully`, 'success');
                } catch (error) {
                    updateStatus(`Error creating Viewer ${viewerNumber}: ${error.message}`, 'error');
                    console.error('Error creating viewer:', error);
                    wrapper.remove();
                }
            });
        }

        function removeViewer(viewerNumber) {
            const index = viewers.findIndex(v => v.number === viewerNumber);
            if (index !== -1) {
                const viewerData = viewers[index];
                try {
                    if (viewerData.viewer) {
                        viewerData.viewer.destroy();
                    }
                } catch (e) {
                    console.warn('Error destroying viewer:', e);
                }
                viewerData.wrapper.remove();
                viewers.splice(index, 1);
                updateViewerCount();
                updateStatus(`Viewer ${viewerNumber} removed`, 'success');
            }
        }

        function removeAllViewers() {
            while (viewers.length > 0) {
                removeViewer(viewers[0].number);
            }
            viewerCounter = 0; // Reset counter so new viewers start at 1
            updateStatus('All viewers removed', 'success');
        }

        function addViewers() {
            const numToAdd = parseInt(document.getElementById('num-viewers').value, 10);
            if (isNaN(numToAdd) || numToAdd < 1) {
                updateStatus('Please enter a valid number of viewers to add', 'error');
                return;
            }

            updateStatus(`Creating ${numToAdd} viewer(s)...`, '');

            // Calculate starting viewer number before the loop to avoid race conditions
            const startNumber = viewerCounter + 1;
            for (let i = 0; i < numToAdd; i++) {
                const viewerNumber = startNumber + i;
                viewerCounter = viewerNumber; // Update counter to track the highest number used
                setTimeout(() => {
                    createViewer(viewerNumber);
                }, i * 100); // Stagger creation slightly
            }
        }

        // Initialize with one viewer
        window.addEventListener('load', function() {
            viewerCounter = 1;
            createViewer(1);
        });

        // Catch global errors
        window.addEventListener('error', function(event) {
            if (event.message && event.message.includes('MAX_TEXTURE_IMAGE_UNITS')) {
                updateStatus('WebGL context error detected! ' + (recoveryEnabled ? 'Recovery should handle this.' : 'Context recovery is disabled - viewer will crash.'), 'error');
            }
        });
    </script>
</body>
</html>
